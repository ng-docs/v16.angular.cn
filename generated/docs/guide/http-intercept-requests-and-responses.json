{"id":"guide/http-intercept-requests-and-responses","title":"HTTP - Intercept requests and responses","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-intercept-requests-and-responses.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http---intercept-requests-and-responses\" translation-result=\"on\">HTTP - 拦截请求和响应<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP - Intercept requests and responses<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">借助拦截机制，你可以声明一些<em>拦截器</em>，它们可以检查并转换从应用中发给服务器的 HTTP 请求。这些拦截器还可以在返回应用的途中检查和转换来自服务器的响应。多个拦截器构成了请求/响应处理器的<em>双向</em>链表。</p><p translation-origin=\"off\">With interception, you declare <em>interceptors</em> that inspect and transform HTTP requests from your application to a server.\nThe same interceptors can also inspect and transform a server's responses on their way back to the application.\nMultiple interceptors form a <em>forward-and-backward</em> chain of request/response handlers.</p>\n\n<p translation-result=\"on\">拦截器可以用一种常规的、标准的方式对每一次 HTTP 的请求/响应任务执行从认证到记日志等很多种<em>隐式</em>任务。</p><p translation-origin=\"off\">Interceptors can perform a variety of  <em>implicit</em> tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</p>\n\n<p translation-result=\"on\">如果没有拦截机制，那么开发人员将不得不对每次 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 调用<em>显式</em>实现这些任务。</p><p translation-origin=\"off\">Without interception, developers would have to implement these tasks <em>explicitly</em> for each <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> method call.</p>\n\n<h2 id=\"write-an-interceptor\" translation-result=\"on\">编写拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Write an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要实现拦截器，就要实现一个实现了 <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 接口中的 <code>intercept()</code> 方法的类。</p><p translation-origin=\"off\">To implement an interceptor, declare a class that implements the <code>intercept()</code> method of the <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> interface.</p>\n\n<p translation-result=\"on\">这里是一个什么也不做的 <code>noop</code> 拦截器，它只会不做任何修改的传递这个请求。</p><p translation-origin=\"off\">Here is a do-nothing <code>noop</code> interceptor that passes the request through without touching it:</p>\n\n<code-example header=\"app/http-interceptors/noop-interceptor.ts\" path=\"http/src/app/http-interceptors/noop-interceptor.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>\n} from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable } from 'rxjs';\n\n/** Pass untouched request through to the next request handler. */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class NoopInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>):\n    Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    return next.handle(req);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>intercept</code> 方法会把请求转换成一个最终返回 HTTP 响应体的 <code>Observable</code>。在这个场景中，每个拦截器都完全能自己处理这个请求。</p><p translation-origin=\"off\">The <code>intercept</code> method transforms a request into an <code>Observable</code> that eventually returns the HTTP response.\nIn this sense, each interceptor is fully capable of handling the request entirely by itself.</p>\n\n<p translation-result=\"on\">大多数拦截器拦截都会在传入时检查请求，然后把潜在的请求转发给 <code>next</code> 对象的 <code>handle()</code> 方法，而 <code>next</code> 对象实现了 <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> 接口。</p><p translation-origin=\"off\">Most interceptors inspect the request on the way in and forward the potentially altered request to the <code>handle()</code> method of the <code>next</code> object which implements the <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> interface.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n\n</code-example>\n<p translation-result=\"on\">像 <code>intercept()</code> 一样，<code>handle()</code> 方法也会把 HTTP 请求转换成 <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> 组成的 <code>Observable</code>，它最终包含的是来自服务器的响应。\n<code>intercept()</code> 函数可以检查这个可观察对象，并在把它返回给调用者之前修改它。</p><p translation-origin=\"off\">Like <code>intercept()</code>, the <code>handle()</code> method transforms an HTTP request into an <code>Observable</code> of <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> which ultimately include the server's response.\nThe <code>intercept()</code> method could inspect that observable and alter it before returning it to the caller.</p>\n\n<p translation-result=\"on\">这个 <code>no-op</code> 拦截器，会使用原始的请求调用 <code>next.handle()</code>，并返回它返回的可观察对象，而不做任何后续处理。</p><p translation-origin=\"off\">This <code>no-op</code> interceptor calls <code>next.handle()</code> with the original request and returns the observable without doing a thing.</p>\n\n<h2 id=\"the-next-object\" translation-result=\"on\"><code>next</code> 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">The <code>next</code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>next</code> 对象表示拦截器链表中的下一个拦截器。这个链表中的最后一个 <code>next</code> 对象就是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的后端处理器（backend handler），它会把请求发给服务器，并接收服务器的响应。</p><p translation-origin=\"off\">The <code>next</code> object represents the next interceptor in the chain of interceptors.\nThe final <code>next</code> in the chain is the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> backend handler that sends the request to the server and receives the server's response.</p>\n\n<p translation-result=\"on\">大多数拦截器都会调用 <code>next.handle()</code> 以便请求流经下一个拦截器，并最终流向后端处理程序。拦截器<em>可以</em>跳过对 <code>next.handle()</code> 的调用，使调用链短路，并<a href=\"guide/http-interceptor-use-cases#caching\">返回带有人工响应体的自定义 <code>Observable</code></a>。</p><p translation-origin=\"off\">Most interceptors call <code>next.handle()</code> so that the request flows through to the next interceptor and, eventually, the backend handler.\nAn interceptor <em>could</em> skip calling <code>next.handle()</code>, short-circuit the chain, and <a href=\"guide/http-interceptor-use-cases#caching\">return its own <code>Observable</code></a> with an artificial server response.</p>\n\n<p translation-result=\"on\">这是一种常见的中间件模式，在像 Express.js 这样的框架中也会找到它。</p><p translation-origin=\"off\">This is a common middleware pattern found in frameworks such as Express.js.</p>\n\n<h2 id=\"provide-the-interceptor\" translation-result=\"on\">提供这个拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Provide the interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">这个 <code>NoopInterceptor</code> 就是一个由 Angular <a href=\"guide/dependency-injection\">依赖注入（DI）</a>系统管理的服务。像其它服务一样，你也必须先提供这个拦截器类，应用才能使用它。</p><p translation-origin=\"off\">The <code>NoopInterceptor</code> is a service managed by Angular's <a href=\"guide/dependency-injection\">dependency injection (DI)</a> system.\nLike other services, you must provide the interceptor class before the app can use it.</p>\n\n<p translation-result=\"on\">由于拦截器是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务的（可选）依赖，所以你必须在提供 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一个（或其各级父注入器）注入器中提供这些拦截器。那些在 DI 创建完 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>之后</em>再提供的拦截器将会被忽略。</p><p translation-origin=\"off\">Because interceptors are optional dependencies of the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service, you must provide them in the same injector or a parent of the injector that provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>.\nInterceptors provided <em>after</em> DI creates the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> are ignored.</p>\n\n<p translation-result=\"on\">由于在 <code>AppModule</code> 中导入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，导致本应用在其根注入器中提供了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>。所以你也同样要在 <code>AppModule</code> 中提供这些拦截器。</p><p translation-origin=\"off\">This app provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in the app's root injector, as a side-effect of importing the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> in <code>AppModule</code>.\nYou should provide interceptors in <code>AppModule</code> as well.</p>\n\n<p translation-result=\"on\">在从 <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 中导入了 <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 注入令牌之后，编写如下的 <code>NoopInterceptor</code> 提供者注册语句：</p><p translation-origin=\"off\">After importing the <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> injection token from <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>, write the <code>NoopInterceptor</code> provider like this:</p>\n\n<code-example path=\"http/src/app/http-interceptors/index.ts\" region=\"noop-provider\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n\n</code-example>\n<p translation-result=\"on\">注意 <code>multi: true</code> 选项。这个必须的选项会告诉 Angular <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一个<em>多重提供者</em>的令牌，表示它会注入一个多值的数组，而不是单一的值。</p><p translation-origin=\"off\">Notice the <code>multi: true</code> option.\nThis required setting tells Angular that <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> is a token for a <em>multiprovider</em> that injects an array of values, rather than a single value.</p>\n\n<p translation-result=\"on\">你<em>也可以</em>直接把这个提供者添加到 <code>AppModule</code> 中的提供者数组中，不过那样会非常啰嗦。况且，你将来还会用这种方式创建更多的拦截器并提供它们。\n你还要<a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">特别注意提供这些拦截器的顺序</a>。</p><p translation-origin=\"off\">You <em>could</em> add this provider directly to the providers array of the <code>AppModule</code>.\nHowever, it's rather verbose and there's a good chance that you'll create more interceptors and provide them in the same way.\nYou must also pay <a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">close attention to the order</a> in which you provide these interceptors.</p>\n\n<p translation-result=\"on\">认真考虑创建一个封装桶（barrel）文件，用于把所有拦截器都收集起来，一起提供给 <code>httpInterceptorProviders</code> 数组，可以先从这个 <code>NoopInterceptor</code> 开始。</p><p translation-origin=\"off\">Consider creating a \"barrel\" file that gathers all the interceptor providers into an <code>httpInterceptorProviders</code> array, starting with this first one, the <code>NoopInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\">\n/* \"Barrel\" of Http Interceptors */\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { NoopInterceptor } from './noop-interceptor';\n\n/** Http interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n];\n\n</code-example>\n<p translation-result=\"on\">然后导入它，并把它加到 <code>AppModule</code> 的 <code>providers array</code> 中，就像这样：</p><p translation-origin=\"off\">Then import and add it to the <code>AppModule</code> <code>providers array</code> like this:</p>\n\n<code-example header=\"app/app.module.ts (interceptor providers)\" path=\"http/src/app/app.module.ts\" region=\"interceptor-providers\">\nproviders: [\n  httpInterceptorProviders\n],\n\n</code-example>\n<p translation-result=\"on\">当你再创建新的拦截器时，就同样把它们添加到 <code>httpInterceptorProviders</code> 数组中，而不用再修改 <code>AppModule</code>。</p><p translation-origin=\"off\">As you create new interceptors, add them to the <code>httpInterceptorProviders</code> array and you won't have to revisit the <code>AppModule</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在完整的示例代码中还有许多其他的拦截器。</p><p translation-origin=\"off\">There are many more interceptors in the complete sample code.</p>\n\n</div>\n<h2 id=\"interceptor-order\" translation-result=\"on\">拦截器的顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Interceptor order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 会按你提供拦截器的顺序应用它们。比如，考虑一个场景：你想处理 HTTP 请求的身份验证并记录它们，然后再将它们发送到服务器。要完成此任务，你可以提供 <code>AuthInterceptor</code> 服务，然后提供 <code>LoggingInterceptor</code> 服务。发出的请求将从 <code>AuthInterceptor</code> 到 <code>LoggingInterceptor</code>。这些请求的响应则沿相反的方向流动，从 <code>LoggingInterceptor</code> 回到 <code>AuthInterceptor</code>。以下是该过程的直观表示：</p><p translation-origin=\"off\">Angular applies interceptors in the order that you provide them.\nFor example, consider a situation in which you want to handle the authentication of your HTTP requests and log them before sending them to a server.\nTo accomplish this task, you could provide an <code>AuthInterceptor</code> service and then a <code>LoggingInterceptor</code> service.\nOutgoing requests would flow from the <code>AuthInterceptor</code> to the <code>LoggingInterceptor</code>.\nResponses from these requests would flow in the other direction, from <code>LoggingInterceptor</code> back to <code>AuthInterceptor</code>.\nThe following is a visual representation of the process:</p>\n\n<div class=\"lightbox\">\n<img alt=\"Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow\" src=\"generated/images/guide/http/interceptor-order.svg\" width=\"300\" height=\"522\">\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">处理过程中的最后一个拦截器始终是 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它负责与服务器通信。</p><p translation-origin=\"off\">The last interceptor in the process is always the <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> that handles communication with the server.</p>\n\n</div>\n<p translation-result=\"on\">以后你就再也不能修改这些顺序或移除某些拦截器了。如果你需要动态启用或禁用某个拦截器，那就要在那个拦截器中自行实现这个功能。</p><p translation-origin=\"off\">You cannot change the order or remove interceptors later.\nIf you need to enable and disable an interceptor dynamically, you'll have to build that capability into the interceptor itself.</p>\n\n<p><a id=\"interceptor-events\"></a></p>\n<h2 id=\"handle-interceptor-events\" translation-result=\"on\">处理拦截器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Handle interceptor events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">大多数 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法都会返回 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 型的可观察对象。<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类本身就是一个事件，它的类型是 <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>。但是，单个 HTTP 请求可以生成其它类型的多个事件，包括报告上传和下载进度的事件。<code>HttpInterceptor.intercept()</code> 和 <code>HttpHandler.handle()</code> 会返回 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 型的可观察对象。</p><p translation-origin=\"off\">Most <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods return observables of <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code>.\nThe <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> class itself is actually an event, whose type is <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>.\nA single HTTP request can, however, generate multiple events of other types, including upload and download progress events.\nThe methods <code>HttpInterceptor.intercept()</code> and <code>HttpHandler.handle()</code> return observables of <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code>.</p>\n\n<p translation-result=\"on\">很多拦截器只关心发出的请求，而对 <code>next.handle()</code> 返回的事件流不会做任何修改。但是，有些拦截器需要检查并修改 <code>next.handle()</code> 的响应。上述做法就可以在流中看到所有这些事件。</p><p translation-origin=\"off\">Many interceptors are only concerned with the outgoing request and return the event stream from <code>next.handle()</code> without modifying it.\nSome interceptors, however, need to examine and modify the response from <code>next.handle()</code>; these operations can see all of these events in the stream.</p>\n\n<p><a id=\"immutability\"></a></p>\n<p translation-result=\"on\">虽然拦截器有能力改变请求和响应，但 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 和 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 实例的属性却是只读（<code>readonly</code>）的，\n因此让它们基本上是不可变的。</p><p translation-origin=\"off\">Although interceptors are capable of modifying requests and responses, the <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> and <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> instance properties are <code>readonly</code>, rendering them largely immutable.\nThey are immutable for a good reason:\nAn app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times.\nIf an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original.\nImmutability ensures that interceptors see the same request for each try.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">除非有充分的理由，否则你的拦截器应该返回每个事件而不进行任何修改。</p><p translation-origin=\"off\">Your interceptor should return every event without modification unless it has a compelling reason to do otherwise.</p>\n\n</div>\n<p translation-result=\"on\">TypeScript 会阻止你设置 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 的只读属性。</p><p translation-origin=\"off\">TypeScript prevents you from setting <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> read-only properties.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\n// Typescript disallows the following assignment because req.url is readonly\nreq.url = req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://');\n\n</code-example>\n<p translation-result=\"on\">如果你必须修改一个请求，先把它克隆一份，修改这个克隆体后再把它传给 <code>next.handle()</code>。你可以在一步中克隆并修改此请求，例子如下。</p><p translation-origin=\"off\">If you must alter a request, clone it first and modify the clone before passing it to <code>next.handle()</code>.\nYou can clone and modify the request in a single step, as shown in the following example.</p>\n\n<code-example header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\">\n// clone request and replace '<a href=\"api/common/http\" class=\"code-anchor\">http</a>://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p translation-result=\"on\">这个 <code>clone()</code> 方法的哈希型参数允许你在复制出克隆体的同时改变该请求的某些特定属性。</p><p translation-origin=\"off\">The <code>clone()</code> method's hash argument lets you mutate specific properties of the request while copying the others.</p>\n\n<h3 id=\"modify-a-request-body\" translation-result=\"on\">修改请求体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Modify a request body<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>readonly</code> 这种赋值保护，无法防范深修改（修改子对象的属性），也不能防范你修改请求体对象中的属性。</p><p translation-origin=\"off\">The <code>readonly</code> assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nreq.body.name = req.body.name.trim(); // bad idea!\n\n</code-example>\n<p translation-result=\"on\">如果必须修改请求体，请执行以下步骤。</p><p translation-origin=\"off\">If you must modify the request body, follow these steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">复制请求体并在副本中进行修改。</p><p translation-origin=\"off\">Copy the body and make your change in the copy.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>clone()</code> 方法克隆这个请求对象。</p><p translation-origin=\"off\">Clone the request object, using its <code>clone()</code> method.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用修改过的副本替换被克隆的请求体。</p><p translation-origin=\"off\">Replace the clone's body with the modified copy.</p>\n\n</li>\n</ol>\n<code-example header=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h3 id=\"clear-the-request-body-in-a-clone\" translation-result=\"on\">清除克隆中的请求正文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Clear the request body in a clone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有时，你需要清除请求体而不是替换它。为此，请将克隆后的请求体设置为 <code>null</code>。</p><p translation-origin=\"off\">Sometimes you need to clear the request body rather than replace it.\nTo do this, set the cloned request body to <code>null</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>提示</strong>：<br>\n如果你将克隆后的请求体设置为 <code>undefined</code>，Angular 就会认为你打算按原样保留请求体。</p><p translation-origin=\"off\"><strong>TIP</strong>: <br>\nIf you set the cloned request body to <code>undefined</code>, Angular assumes you intend to leave the body as is.</p>\n\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\nnewReq = req.clone({ … }); // body not mentioned =&gt; preserve original body\nnewReq = req.clone({ body: undefined }); // preserve original body\nnewReq = req.clone({ body: null }); // clear the body\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：3/16/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-track-show-request-progress\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/dependency-injection\n - guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\n - guide/http-intercept-requests-and-responses#handle-interceptor-events\n - guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\n - guide/http-intercept-requests-and-responses#http---拦截请求和响应\n - guide/http-intercept-requests-and-responses#interceptor-events\n - guide/http-intercept-requests-and-responses#interceptor-order\n - guide/http-intercept-requests-and-responses#modify-a-request-body\n - guide/http-intercept-requests-and-responses#next-对象\n - guide/http-intercept-requests-and-responses#provide-the-interceptor\n - guide/http-intercept-requests-and-responses#the-next-object\n - guide/http-intercept-requests-and-responses#write-an-interceptor\n - guide/http-intercept-requests-and-responses#修改请求体\n - guide/http-intercept-requests-and-responses#处理拦截器事件\n - guide/http-intercept-requests-and-responses#拦截器的顺序\n - guide/http-intercept-requests-and-responses#提供这个拦截器\n - guide/http-intercept-requests-and-responses#清除克隆中的请求正文\n - guide/http-intercept-requests-and-responses#编写拦截器\n - guide/http-interceptor-use-cases#caching\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-intercept-requests-and-responses.md?message=docs%3A%20请简述你的修改...\n-->"}