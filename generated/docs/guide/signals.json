{"id":"guide/signals","title":"Angular Signals","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/signals.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-signals\" translation-result=\"on\">Angular 信号（Signal）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Angular Signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>Angular 信号（Signal）</strong>是一个体系，可以精细地跟踪你的状态在整个应用程序中的使用方式和位置，从而允许框架优化渲染更新。</p><p translation-origin=\"off\"><strong>Angular Signals</strong> is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize\nrendering updates.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">Angular信号已经提供了<a href=\"/guide/releases#developer-preview\">开发者预览版</a>。你已经可以尝试使用它，但在稳定之前可能会发生变化。</p><p translation-origin=\"off\">Angular signals are available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. They're ready for you to try, but may change before they are stable.</p>\n\n</div>\n<h2 id=\"what-are-signals\" translation-result=\"on\">什么是信号？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What are signals?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>信号</strong>是一个值的包装器，可以在该值发生变化时通知感兴趣的消费者。信号可以包含任何值，从简单的原语到复杂的数据结构。</p><p translation-origin=\"off\">A <strong>signal</strong> is a wrapper around a value that can notify interested consumers when that value changes. Signals can contain any value, from simple primitives to complex data structures.</p>\n\n<p translation-result=\"on\">信号的值总会通过 getter 函数读取，这使得 Angular 可以跟踪信号的使用位置。</p><p translation-origin=\"off\">A signal's value is always read through a getter function, which allows Angular to track where the signal is used.</p>\n\n<p translation-result=\"on\">信号可以是<strong>可写的</strong>或<strong>只读的</strong>。</p><p translation-origin=\"off\">Signals may be either <em>writable</em> or <em>read-only</em>.</p>\n\n<h3 id=\"writable-signals\" translation-result=\"on\">可写信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可写信号提供了一个 API 来直接更新它们的值。你可以通过使用信号的初始值调用 <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> 函数来创建可写信号：</p><p translation-origin=\"off\">Writable signals provide an API for updating their values directly. You create writable signals by calling the <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> function with the signal's initial value:</p>\n\n<code-example language=\"ts\">\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n</code-example>\n<p translation-result=\"on\">要更改可写信号的值，你可以直接 <code>.set()</code>：</p><p translation-origin=\"off\">To change the value of a writable signal, you can either <code>.set()</code> it directly:</p>\n\n<code-example language=\"ts\">\ncount.set(3);\n</code-example>\n<p translation-result=\"on\">或者使用 <code>.update()</code> 操作从前一个值计算出一个新值：</p><p translation-origin=\"off\">or use the <code>.update()</code> operation to compute a new value from the previous one:</p>\n\n<code-example language=\"ts\">\n// Increment the count by 1.\ncount.update(value =&gt; value + 1);\n</code-example>\n<p translation-result=\"on\">在处理包含对象的信号时，有时直接改变该对象很有用。例如，如果对象是一个数组，你可能希望在不完全替换数组的情况下推送一个新值。要进行这样的内部更改，请使用 <code>.mutate</code> 方法：</p><p translation-origin=\"off\">When working with signals that contain objects, it's sometimes useful to mutate that object directly. For example, if the object is an array, you may want to push a new value without replacing the array entirely. To make an internal change like this, use the <code>.mutate</code> method:</p>\n\n<code-example language=\"ts\">\nconst todos = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>([{title: 'Learn signals', done: false}]);\n\ntodos.mutate(value =&gt; {\n  // Change the first TODO in the array to 'done: true' without replacing it.\n  value[0].done = true;\n});\n</code-example>\n<p translation-result=\"on\">可写信号的类型为 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p><p translation-origin=\"off\">Writable signals have the type <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n\n<h3 id=\"computed-signals\" translation-result=\"on\">计算（computed）信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Computed signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>计算信号</strong>是从其他信号中派生出来的。可以使用 <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> 并指定推导函数来定义一个：</p><p translation-origin=\"off\">A <strong>computed signal</strong> derives its value from other signals. Define one using <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> and specifying a derivation function:</p>\n\n<code-example language=\"typescript\">\nconst count: <a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a>&lt;number&gt; = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst doubleCount: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;number&gt; = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; count() * 2);\n</code-example>\n<p translation-result=\"on\"><code>doubleCount</code> 信号取决于 <code>count</code>。每当 <code>count</code> 更新时，Angular 知道任何依赖于 <code>count</code> 或 <code>doubleCount</code> 东西也需要更新。</p><p translation-origin=\"off\">The <code>doubleCount</code> signal depends on <code>count</code>. Whenever <code>count</code> updates, Angular knows that anything which depends on either <code>count</code> or <code>doubleCount</code> needs to update as well.</p>\n\n<h4 id=\"computeds-are-both-lazily-evaluated-and-memoized\" translation-result=\"on\">计算信号都是惰性计算和记忆的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computeds-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computeds are both lazily evaluated and memoized<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computeds-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在第一次读取 <code>doubleCount</code> 之前，不会运行 <code>doubleCount</code> 的派生函数以计算其值。一旦计算出来，这个值就会被缓存起来，以后读取 <code>doubleCount</code> 将返回缓存的值而不用重新计算。</p><p translation-origin=\"off\"><code>doubleCount</code>'s derivation function does not run to calculate its value until the first time <code>doubleCount</code> is read. Once calculated, this value is cached, and future reads of <code>doubleCount</code> will return the cached value without recalculating.</p>\n\n<p translation-result=\"on\">当 <code>count</code> 发生变化时，它会告诉 <code>doubleCount</code> 它的缓存值不再有效，并且该值只会在下一次读取 <code>doubleCount</code> 时重新计算。</p><p translation-origin=\"off\">When <code>count</code> changes, it tells <code>doubleCount</code> that its cached value is no longer valid, and the value is only recalculated on the next read of <code>doubleCount</code>.</p>\n\n<p translation-result=\"on\">因此，在计算信号中执行计算量大的推导（例如过滤数组）是相当安全的。</p><p translation-origin=\"off\">As a result, it's safe to perform computationally expensive derivations in computed signals, such as filtering arrays.</p>\n\n<h4 id=\"computed-signals-are-not-writable-signals\" translation-result=\"on\">计算信号不是可写信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computed signals are not writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你不能直接为计算信号赋值。比如，</p><p translation-origin=\"off\">You cannot directly assign values to a computed signal. That is,</p>\n\n<code-example language=\"ts\">\ndoubleCount.set(3);\n</code-example>\n<p translation-result=\"on\">会产生编译错误，因为 <code>doubleCount</code> 不是 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p><p translation-origin=\"off\">produces a compilation error, because <code>doubleCount</code> is not a <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n\n<h4 id=\"computed-signal-dependencies-are-dynamic\" translation-result=\"on\">计算信号的依赖性是动态的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computed signal dependencies are dynamic<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">只能跟踪推导期间实际读取过的信号。例如，在此计算中，只会有条件地读取 <code>count</code> 信号：</p><p translation-origin=\"off\">Only the signals actually read during the derivation are tracked. For example, in this computed the <code>count</code> signal is only read conditionally:</p>\n\n<code-example language=\"ts\">\nconst showCount = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst conditionalCount = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n</code-example>\n<p translation-result=\"on\">读取 <code>conditionalCount</code> 时，如果 <code>showCount</code> 为 <code>false</code>，则<strong>没有</strong>读取 <code>count</code> 信号就返回了消息 “Nothing to see here!”。这意味着对 <code>count</code> 的更新不会导致重新计算。</p><p translation-origin=\"off\">When reading <code>conditionalCount</code>, if <code>showCount</code> is <code>false</code> the \"Nothing to see here!\" message is returned <em>without</em> reading the <code>count</code> signal. This means that updates to <code>count</code> will not result in a recomputation.</p>\n\n<p translation-result=\"on\">如果稍后将 <code>showCount</code> 设置为 <code>true</code> 并再次读取 <code>conditionalCount</code>，则将重新执行派生并采用 <code>showCount</code> 为 <code>true</code> 的分支，返回显示 <code>count</code> 值的消息。对 <code>count</code> 的更改将使 <code>conditionalCount</code> 的缓存值无效。</p><p translation-origin=\"off\">If <code>showCount</code> is later set to <code>true</code> and <code>conditionalCount</code> is read again, the derivation will re-execute and take the branch where <code>showCount</code> is <code>true</code>, returning the message which shows the value of <code>count</code>. Changes to <code>count</code> will then invalidate <code>conditionalCount</code>'s cached value.</p>\n\n<p translation-result=\"on\">请注意，可以删除和添加依赖项。如果 <code>showCount</code> 稍后再次设置为 <code>false</code>，则 <code>count</code> 将不再被视为 <code>conditionalCount</code> 的依赖项。</p><p translation-origin=\"off\">Note that dependencies can be removed as well as added. If <code>showCount</code> is later set to <code>false</code> again, then <code>count</code> will no longer be considered a dependency of <code>conditionalCount</code>.</p>\n\n<h2 id=\"reading-signals-in-onpush-components\" translation-result=\"on\">在 <code>OnPush</code> 型组件中读取信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Reading signals in <code>OnPush</code> components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当 <code>OnPush</code> 组件在其模板中使用信号值时，Angular 会将信号作为该组件的依赖项进行跟踪。当该信号更新时，Angular 会自动<a href=\"/api/core/ChangeDetectorRef#markforcheck\">标记</a>组件以确保它在下次运行变更检测时得到更新。有关 <code>OnPush</code> 组件的更多信息，请参阅<a href=\"/guide/change-detection-skipping-subtrees\">跳过组件子树</a>指南。</p><p translation-origin=\"off\">When an <code>OnPush</code> component uses a signal's value in its template, Angular will track the signal as a dependency of that component. When that signal is updated, Angular automatically <a href=\"/api/core/ChangeDetectorRef#markforcheck\">marks</a> the component to ensure it gets updated the next time change detection runs. Refer to the <a href=\"/guide/change-detection-skipping-subtrees\">Skipping component subtrees</a> guide for more information about <code>OnPush</code> components.</p>\n\n<h2 id=\"effects\" translation-result=\"on\">副作用（effect）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">信号很有用，因为它们可以在变化时通知感兴趣的消费者。<strong>副作用</strong>是一种操作，只要一个或多个信号值发生变化就会运行。你可以使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 函数创建副作用：</p><p translation-origin=\"off\">Signals are useful because they can notify interested consumers when they change. An <strong>effect</strong> is an operation that runs whenever one or more signal values change. You can create an effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> function:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`The current count is: ${count()}`);\n});\n</code-example>\n<p translation-result=\"on\">副作用<strong>至少会运行一次。</strong> 当副作用运行时，它会跟踪任何信号值读取。只要这些信号值中的任何一个发生变化，副作用就会再次运行。与计算信号类似，副作用会动态跟踪它们的依赖关系，并且仅跟踪在最近一次执行中读取的信号。</p><p translation-origin=\"off\">Effects always run <strong>at least once.</strong> When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals which were read in the most recent execution.</p>\n\n<p translation-result=\"on\">在变化检测过程中，副作用始终<strong>异步</strong>执行。</p><p translation-origin=\"off\">Effects always execute <strong>asynchronously</strong>, during the change detection process.</p>\n\n<h3 id=\"uses-for-effects\" translation-result=\"on\">何时使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#uses-for-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Uses for effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#uses-for-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在大多数应用程序代码中很少需要副作用，但在特定情况下可能会有用。下面是一些需要以 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 作为解决方案的例子：</p><p translation-origin=\"off\">Effects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> might be a good solution:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">记录正在显示的数据及其更改时间，用于分析或作为调试工具</p><p translation-origin=\"off\">Logging data being displayed and when it changes, either for analytics or as a debugging tool</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在数据与 <code>window.localStorage</code> 之间保持同步</p><p translation-origin=\"off\">Keeping data in sync with <code>window.localStorage</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">添加无法用模板语法表达的自定义 DOM 行为</p><p translation-origin=\"off\">Adding custom DOM behavior that can't be expressed with template syntax</p>\n\n</li>\n<li>\n<p translation-result=\"on\">对 <code>&lt;canvas&gt;</code>、图表库或其他第三方 UI 库执行自定义渲染</p><p translation-origin=\"off\">Performing custom rendering to a <code>&lt;canvas&gt;</code>, charting library, or other third party UI library</p>\n\n</li>\n</ul>\n<h4 id=\"when-not-to-use-effects\" translation-result=\"on\">何时不使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">When not to use effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">要避免使用副作用来传播状态变更。这可能会导致 <code>ExpressionChangedAfterItHasBeenChecked</code> 错误、导致无限循环更新或导致不必要的变更检测周期。</p><p translation-origin=\"off\">Avoid using effects for propagation of state changes. This can result in <code>ExpressionChangedAfterItHasBeenChecked</code> errors, infinite circular updates, or unnecessary change detection cycles.</p>\n\n<p translation-result=\"on\">由于存在这些风险，在副作用中默认不允许设置信号，但在绝对必要时也可以启用。</p><p translation-origin=\"off\">Because of these risks, setting signals is disallowed by default in effects, but can be enabled if absolutely necessary.</p>\n\n<h3 id=\"injection-context\" translation-result=\"on\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">默认情况下，使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> 函数注册新的副作用需要“注入上下文”（访问 <code>inject</code> 函数）。提供此功能的最简单方法是在组件、指令或服务的 <code>constructor</code> 中调用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">By default, registering a new effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> function requires an \"injection context\" (access to the <code>inject</code> function). The easiest way to provide this is to call <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> within a component, directive, or service <code>constructor</code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor() {\n    // Register a new effect.\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    });\n  }\n}\n</code-example>\n<p translation-result=\"on\">或者，可以将副作用赋值给一个字段（这也会为其提供一个描述性名称）。</p><p translation-origin=\"off\">Alternatively, the effect can be assigned to a field (which also gives it a descriptive name).</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  \n  private loggingEffect = <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n    console.log(`The count is: ${this.count()})`);\n  });\n}\n</code-example>\n<p translation-result=\"on\">要在构造函数之外创建副作用，你可以通过 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 的选项传递 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 以产生 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">To create an effect outside of the constructor, you can pass an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> to <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> via its options:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {}\n\n  initializeLogging(): void {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    }, {injector: this.injector});\n  }\n}\n</code-example>\n<h3 id=\"destroying-effects\" translation-result=\"on\">销毁副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Destroying effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当你创建一个副作用时，它会在其闭包上下文被销毁时自动销毁。这意味着当组件被销毁时，在组件内创建的副作用也会被销毁。指令、服务等中的副作用也是如此。</p><p translation-origin=\"off\">When you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc.</p>\n\n<p translation-result=\"on\">副作用返回一个 <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code>，可用于通过 <code>.destroy()</code> 操作手动销毁它们。这也可以与 <code>manualCleanup</code> 选项结合使用，以创建持续到手动销毁为止的副作用。当不再需要这些副作用时，要小心地实际清理它们。</p><p translation-origin=\"off\">Effects return an <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code> that can be used to destroy them manually, via the <code>.destroy()</code> operation. This can also be combined with the <code>manualCleanup</code> option to create an effect that lasts until it is manually destroyed. Be careful to actually clean up such effects when they're no longer required.</p>\n\n<h2 id=\"advanced-topics\" translation-result=\"on\">高级主题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"signal-equality-functions\" translation-result=\"on\">信号相等性判定函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Signal equality functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">创建信号时，你可以选择提供相等性判定函数，该函数将用于检查新值是否真的与前一个值不同。</p><p translation-origin=\"off\">When creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one.</p>\n\n<code-example language=\"ts\">\nimport _ from 'lodash';\n\nconst data = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> won't\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> any updates.\ndata.set(['test']);\n</code-example>\n<p translation-result=\"on\">可以为可写信号和计算信号提供相等性判定函数。</p><p translation-origin=\"off\">Equality functions can be provided to both writable and computed signals.</p>\n\n<p translation-result=\"on\">对于可写信号，<code>.mutate()</code> 不会检查相等性，因为它改变了当前值而不会产生新的引用。</p><p translation-origin=\"off\">For writable signals, <code>.mutate()</code> does not check for equality because it mutates the current value without producing a new reference.</p>\n\n<h3 id=\"reading-without-tracking-dependencies\" translation-result=\"on\">阅读而不跟踪依赖关系<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading without tracking dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在极少数情况下，你可能希望在响应式函数（如<code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>或<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>）中执行可能读取信号的代码，但<strong>不希望</strong>创建一个依赖项。</p><p translation-origin=\"off\">Rarely, you may want to execute code which may read signals in a reactive function such as <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> or <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> <em>without</em> creating a dependency.</p>\n\n<p translation-result=\"on\">例如，假设当 <code>currentUser</code> 发生变化时，应该记录 <code>counter</code> 的值。创建读取这两个信号的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">For example, suppose that when <code>currentUser</code> changes, the value of a <code>counter</code> should be logged. Creating an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> which reads both signals:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${counter()}`);\n});\n</code-example>\n<p translation-result=\"on\">此示例会在 <code>counter</code> 或 <code>currentUser</code> 发生变化时，记录一条消息。但是，如果副作用只应该在 <code>currentUser</code> 更改时才运行，则只会偶尔读取 <code>counter</code>，因此对 <code>counter</code> 的更改不应记录新消息。</p><p translation-origin=\"off\">This example logs a message when <em>either</em> <code>currentUser</code> or <code>counter</code> changes. However, if the effect should only run when <code>currentUser</code> changes, then the read of <code>counter</code> is only incidental and changes to <code>counter</code> shouldn't log a new message.</p>\n\n<p translation-result=\"on\">你可以通过使用 <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 调用其 getter 来防止对信号的读取被跟踪：</p><p translation-origin=\"off\">You can prevent a signal read from being tracked by calling its getter with <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code>:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${<a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(counter)}`);\n});\n</code-example>\n<p translation-result=\"on\">当副作用需要调用一些不应被视为依赖项的外部代码时，<code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 也很有用：</p><p translation-origin=\"off\"><code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  const user = currentUser();\n  <a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(() =&gt; {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n</code-example>\n<h3 id=\"effect-cleanup-functions\" translation-result=\"on\">副作用清理函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Effect cleanup functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">副作用可能会启动长时间运行的操作，如果副作用在第一个操作完成之前就被销毁或再次运行，则应取消该操作。创建副作用时，你的函数可以用 <code>onCleanup</code> 函数作为其第一个参数。这个 <code>onCleanup</code> 函数允许你注册一个回调，该回调在副作用的下一次运行开始之前或副作用被销毁时调用。</p><p translation-origin=\"off\">Effects might start long-running operations, which should be cancelled if the effect is destroyed or runs again before the first operation finished. When you create an effect, your function can optionally accept an <code>onCleanup</code> function as its first parameter. This <code>onCleanup</code> function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed.</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>((onCleanup) =&gt; {\n  const user = currentUser();\n\n  const timer = setTimeout(() =&gt; {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() =&gt; {\n    clearTimeout(timer);\n  });\n});\n</code-example>\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectorRef#markforcheck\n - /guide/change-detection-skipping-subtrees\n - /guide/releases#developer-preview\n - api/animations/trigger\n - api/core/Component\n - api/core/EffectRef\n - api/core/Injector\n - api/core/Signal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - api/core/untracked\n - guide/signals#advanced-topics\n - guide/signals#angular-signals\n - guide/signals#angular-信号signal\n - guide/signals#computed-signal-dependencies-are-dynamic\n - guide/signals#computed-signals\n - guide/signals#computed-signals-are-not-writable-signals\n - guide/signals#computeds-are-both-lazily-evaluated-and-memoized\n - guide/signals#destroying-effects\n - guide/signals#effect-cleanup-functions\n - guide/signals#effects\n - guide/signals#injection-context\n - guide/signals#reading-signals-in-onpush-components\n - guide/signals#reading-without-tracking-dependencies\n - guide/signals#signal-equality-functions\n - guide/signals#uses-for-effects\n - guide/signals#what-are-signals\n - guide/signals#when-not-to-use-effects\n - guide/signals#writable-signals\n - guide/signals#什么是信号\n - guide/signals#何时不使用副作用\n - guide/signals#何时使用副作用\n - guide/signals#信号相等性判定函数\n - guide/signals#副作用effect\n - guide/signals#副作用清理函数\n - guide/signals#可写信号\n - guide/signals#在-onpush-型组件中读取信号\n - guide/signals#注入上下文\n - guide/signals#计算computed信号\n - guide/signals#计算信号不是可写信号\n - guide/signals#计算信号的依赖性是动态的\n - guide/signals#计算信号都是惰性计算和记忆的\n - guide/signals#销毁副作用\n - guide/signals#阅读而不跟踪依赖关系\n - guide/signals#高级主题\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/signals.md?message=docs%3A%20请简述你的修改...\n-->"}