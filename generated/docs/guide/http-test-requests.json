{"id":"guide/http-test-requests","title":"HTTP client - Test requests","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-test-requests.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-client---test-requests\" translation-result=\"on\">HTTP 客户端 - 测试请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP client - Test requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">如同所有的外部依赖一样，你必须把 HTTP 后端也 Mock 掉，以便你的测试可以模拟这种与后端的互动。<code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> 库能让这种 Mock 工作变得直截了当。</p><p translation-origin=\"off\">As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server.\nThe <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> library makes it straightforward to set up such mocking.</p>\n\n<h2 id=\"http-testing-library\" translation-result=\"on\">HTTP 测试库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">HTTP testing library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 的 HTTP 测试库是专为其中的测试模式而设计的。在这种模式下，会首先在应用中执行代码并发起请求。然后，这个测试会期待发起或未发起过某个请求，并针对这些请求进行断言，最终对每个所预期的请求进行刷新（flush）来对这些请求提供响应。</p><p translation-origin=\"off\">Angular's HTTP testing library is designed for a pattern of testing in which the app executes code and makes requests first.\nThe test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.</p>\n\n<p translation-result=\"on\">最终，测试可能会验证这个应用不曾发起过非预期的请求。</p><p translation-origin=\"off\">At the end, tests can verify that the app made no unexpected requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以到在线编程环境中运行<live-example stackblitz=\"specs\">这些范例测试</live-example>。</p><p translation-origin=\"off\">You can run <live-example stackblitz=\"specs\">these sample tests</live-example> in a live coding environment.</p>\n\n<p translation-result=\"on\">本章所讲的这些测试位于 <code>src/testing/http-client.spec.ts</code> 中。在 <code>src/app/heroes/heroes.service.spec.ts</code> 中还有一些测试，用于测试那些调用了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的数据服务。</p><p translation-origin=\"off\">The tests described in this guide are in <code>src/testing/http-client.spec.ts</code>.\nThere are also tests of an application data service that call <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in <code>src/app/heroes/heroes.service.spec.ts</code>.</p>\n\n</div>\n<h2 id=\"setup-for-testing\" translation-result=\"on\">搭建测试环境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup for testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要开始测试那些通过 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 发起的请求，就要导入 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 模块和模拟控制器（<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>）以及你测试所需的其他符号。</p><p translation-origin=\"off\">To begin testing calls to <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, import the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> and the mocking controller, <code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>, along with the other symbols your tests require.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p translation-result=\"on\">然后把 <code>HTTPClientTestingModule</code> 添加到 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，并继续设置<em>被测服务</em>。</p><p translation-origin=\"off\">Then add the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> to the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> and continue with the setup of the <em>service-under-test</em>.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p translation-result=\"on\">现在，在测试中发起的这些请求会发给这些测试用的后端（testing backend），而不是标准的后端。</p><p translation-origin=\"off\">Now requests made in the course of your tests hit the testing backend instead of the normal backend.</p>\n\n<p translation-result=\"on\">这种设置还会调用 <code>TestBed.inject()</code>，来获取注入的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务和模拟控制器，以便在测试期间引用它们。</p><p translation-origin=\"off\">This setup also calls <code>TestBed.inject()</code> to inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service and the mocking controller so they can be referenced during the tests.</p>\n\n<h2 id=\"expect-and-answer-requests\" translation-result=\"on\">期待并回答请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Expect and answer requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">现在，你就可以编写测试，等待 GET 请求并给出模拟响应。</p><p translation-origin=\"off\">Now you can write a test that expects a GET Request to occur and provides a mock response.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p translation-result=\"on\">最后一步，验证没有发起过预期之外的请求，足够通用，因此你可以把它移到 <code>afterEach()</code> 中：</p><p translation-origin=\"off\">The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h3 id=\"custom-request-expectations\" translation-result=\"on\">自定义对请求的预期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Custom request expectations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果仅根据 URL 匹配还不够，你还可以自行实现匹配函数。比如，你可以验证外发的请求是否带有某个认证头：</p><p translation-origin=\"off\">If matching by URL isn't sufficient, it's possible to implement your own matching function.\nFor example, you could look for an outgoing request that has an authorization header:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request =&gt; request.headers.has('Authorization')\n);\n\n</code-example>\n<p translation-result=\"on\">像前面的 <code>expectOne()</code> 测试一样，如果零或两个以上的请求满足了这个断言，它就会抛出异常。</p><p translation-origin=\"off\">As with the previous <code>expectOne()</code>, the test fails if 0 or 2+ requests satisfy this predicate.</p>\n\n<h3 id=\"handle-more-than-one-request\" translation-result=\"on\">处理多个请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Handle more than one request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你需要在测试中对重复的请求进行响应，可以使用 <code>match()</code> API 来代替 <code>expectOne()</code>，它的参数不变，但会返回一个与这些请求相匹配的数组。一旦返回，这些请求就会从将来要匹配的列表中移除，你要自己验证和刷新（flush）它。</p><p translation-origin=\"off\">If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>.\nIt takes the same arguments but returns an array of matching requests.\nOnce returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h2 id=\"test-for-errors\" translation-result=\"on\">对报错进行测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Test for errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你还要测试应用对于 HTTP 请求失败时的防护。</p><p translation-origin=\"off\">You should test the app's defenses against HTTP requests that fail.</p>\n\n<p translation-result=\"on\">调用 <code>request.flush()</code> 并传入一个错误信息，如下所示。</p><p translation-origin=\"off\">Call <code>request.flush()</code> with an error message, as seen in the following example.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p translation-result=\"on\">另外，还可以用 <code>ProgressEvent</code> 来调用 <code>request.error()</code>。</p><p translation-origin=\"off\">Alternatively, call <code>request.error()</code> with a <code>ProgressEvent</code>.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done =&gt; {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：11/14/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/router/Data\n - guide/http-test-requests#custom-request-expectations\n - guide/http-test-requests#expect-and-answer-requests\n - guide/http-test-requests#handle-more-than-one-request\n - guide/http-test-requests#http-client---test-requests\n - guide/http-test-requests#http-testing-library\n - guide/http-test-requests#http-客户端---测试请求\n - guide/http-test-requests#http-测试库\n - guide/http-test-requests#setup-for-testing\n - guide/http-test-requests#test-for-errors\n - guide/http-test-requests#处理多个请求\n - guide/http-test-requests#对报错进行测试\n - guide/http-test-requests#搭建测试环境\n - guide/http-test-requests#期待并回答请求\n - guide/http-test-requests#自定义对请求的预期\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-test-requests.md?message=docs%3A%20请简述你的修改...\n-->"}