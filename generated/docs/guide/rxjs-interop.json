{"id":"guide/rxjs-interop","title":"RxJS Interop","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/rxjs-interop.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"rxjs-interop\" translation-result=\"on\">RxJS 互操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">RxJS Interop<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">RxJS 互操作性包已经提供了<a href=\"/guide/releases#developer-preview\">开发者预览版</a>。你已经可以尝试使用它，但在稳定之前可能会发生变化。</p><p translation-origin=\"off\">The RxJS Interop package is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n\n</div>\n<p translation-result=\"on\">Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 包，它提供了有用的实用程序来将 <a href=\"/guide/signals\">Angular 信号（Signal）</a> 与 RxJS 可观察对象（Observable）集成起来。</p><p translation-origin=\"off\">Angular's <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> package which provides useful utilities to integrate <a href=\"/guide/signals\">Angular Signals</a> with RxJS Observables.</p>\n\n<h2 id=\"tosignal\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#tosignal\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 函数创建一个跟踪 Observable 值的信号。它的行为类似于模板中的 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道，但更灵活，可以在应用程序的任何地方使用。</p><p translation-origin=\"off\">The <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> function creates a signal which tracks the value of an Observable. It behaves similarly to the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe in templates, but is more flexible and can be used anywhere in an application.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a> } from '@angular/common';\nimport { interval } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `{{ counter() }}`,\n})\nexport class Ticker {\n  counterObservable = interval(1000);\n\n  // Get a `<a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>` representing the `counterObservable`'s value.\n  counter = <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a>(this.counterObservable, {initialValue: 0});\n}\n</code-example>\n<p translation-result=\"on\">与 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道一样，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 会立即订阅 Observable，这可能会引发副作用。<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 创建的订阅会在销毁调用 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 的组件时自动取消对给定 Observable 的订阅。</p><p translation-origin=\"off\">Like the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> subscribes to the Observable immediately, which may trigger side effects. The subscription created by\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the given Observable upon destruction of the the component in which <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called.</p>\n\n<h3 id=\"initial-values\" translation-result=\"on\">初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Observable 可能不会在订阅时同步产生一个值，但信号总是需要一个当前值。有几种方法可以处理 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 信号的这个“初始”值。</p><p translation-origin=\"off\">Observables may not produce a value synchronously on subscription, but signals always require a current value. There are several ways to deal with this \"initial\" value of <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> signals.</p>\n\n<h4 id=\"the-initialvalue-option\" translation-result=\"on\"><code>initialValue</code> 选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code>initialValue</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如上例所示，<code>initialValue</code> 选项指定信号在 Observable 首次发射之前应返回的值。</p><p translation-origin=\"off\">As in the example above, the <code>initialValue</code> option specifies the value the signal should return before the Observable emits for the first time.</p>\n\n<h4 id=\"undefined-initial-values\" translation-result=\"on\"><code>undefined</code> 初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>undefined</code> initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果省略了 <code>initialValue</code>，则 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 返回的信号将返回 <code>undefined</code> 直到 Observable 发出为止。这类似于 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道返回 <code>null</code> 的行为。</p><p translation-origin=\"off\">If <code>initialValue</code> is omitted, the signal returned by <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> returns <code>undefined</code> until the Observable emits. This is similar to the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe's behavior of returning <code>null</code>.</p>\n\n<h4 id=\"the-requiresync-option\" translation-result=\"on\"><code>requireSync</code> 选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code>requireSync</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">已知一些 Observable 是同步发出的，例如 <code>BehaviorSubject</code>。在这些情况下，你可以指定 <code>requireSync: true</code> 选项。</p><p translation-origin=\"off\">Some Observables are known to emit synchronously, such as <code>BehaviorSubject</code>. In those cases, you can specify the <code>requireSync: true</code> option.</p>\n\n<p translation-result=\"on\">当 <code>requiredSync</code> 为 <code>true</code> 时，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 强制 Observable 在订阅时同步发出值。这保证了信号总是有一个值，并且不需要用 <code>undefined</code> 类型或初始值。</p><p translation-origin=\"off\">When <code>requiredSync</code> is <code>true</code>, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> enforces that the Observable emits synchronously on subscription. This guarantees that the signal always has a value, and no <code>undefined</code> type or initial value is required.</p>\n\n<h3 id=\"manualcleanup\"><code>manualCleanup</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#manualcleanup\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">默认情况下，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 在创建它的上下文被销毁时自动取消订阅 Observable。例如，如果在组件创建期间调用 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>，它会在组件销毁时清除其订阅。</p><p translation-origin=\"off\">By default, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the Observable upon destruction of the context in which it's created. For example, if <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called during creation of a component, it cleans up its subscription when the component is destroyed.</p>\n\n<p translation-result=\"on\"><code>manualCleanup</code> 选项会禁用此自动清理。你可以将此设置用于会自然结束的 Observable。</p><p translation-origin=\"off\">The <code>manualCleanup</code> option disables this automatic cleanup. You can use this setting for Observables that complete themselves naturally.</p>\n\n<h3 id=\"error-and-completion\" translation-result=\"on\">出错与结束<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Error and Completion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果在 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 产生了错误，则在读取信号时就会抛出该错误。</p><p translation-origin=\"off\">If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> produces an error, that error is thrown when the signal is read.</p>\n\n<p translation-result=\"on\">如果 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 结束了，则信号会继续返回结束前最近发出的值。</p><p translation-origin=\"off\">If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> completes, the signal continues to return the most recently emitted value before completion.</p>\n\n<h2 id=\"toobservable\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 实用程序会创建一个跟踪信号值的 <code>Observable</code>。信号的值由一个 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 监控，它会在值发生变化时将值发送给 Observable。</p><p translation-origin=\"off\">The <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> utility creates an <code>Observable</code> which tracks the value of a signal. The signal's value is monitored with an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>, which emits the value to the Observable when it changes.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nexport class SearchResults {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;string&gt; = inject(QueryService).query;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(this.query);\n\n  results$ = this.query$.pipe(\n    switchMap(<a href=\"api/animations/query\" class=\"code-anchor\">query</a> =&gt; this.http.get('/search?q=' + <a href=\"api/animations/query\" class=\"code-anchor\">query</a> ))\n  );\n}\n</code-example>\n<p translation-result=\"on\">随着 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 信号的变化，<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable 发出最新的查询并触发一个新的 HTTP 请求。</p><p translation-origin=\"off\">As the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> signal changes, the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable emits the latest query and triggers a new HTTP request.</p>\n\n<h3 id=\"injection-context\" translation-result=\"on\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 默认情况下需要在注入上下文中运行，例如在构建组件或服务期间。如果注入上下文不可用，则可以显式指定 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>。</p><p translation-origin=\"off\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> by default needs to run in an injection context, such as during construction of a component or service. If an injection context is not available, an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> can instead be explicitly specified.</p>\n\n<h3 id=\"timing-of-toobservable\" translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 的时序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable-的时序\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Timing of <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#timing-of-toobservable\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 来跟踪 <code>ReplaySubject</code> 中的信号值。在订阅时，第一个值（如果可用）可以同步发出，所有后续值都将是异步的。</p><p translation-origin=\"off\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> uses an effect to track the value of the signal in a <code>ReplaySubject</code>. On subscription, the first value (if available) may be emitted synchronously, and all subsequent values will be asynchronous.</p>\n\n<p translation-result=\"on\">与 Observable 不同，信号从来不会提供同步的变化通知。即使你的代码多次更新信号值，依赖于信号值的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 也只会在信号“稳定”后运行。</p><p translation-origin=\"off\">Unlike Observables, signals never provide a synchronous notification of changes. Even if your code updates a signal's value multiple times, effects which depend on its value run only after the signal has \"settled\".</p>\n\n<code-example language=\"ts\">\nconst obs$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(mySignal);\nobs$.subscribe(value =&gt; console.log(value));\n\nmySignal.set(1);\nmySignal.set(2);\nmySignal.set(3);\n</code-example>\n<p translation-result=\"on\">在这里，只会记录最后一个值（3）。</p><p translation-origin=\"off\">Here, only the last value (3) will be logged.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/releases#developer-preview\n - /guide/signals\n - api/animations/query\n - api/common/AsyncPipe\n - api/core/Component\n - api/core/Injector\n - api/core/Signal\n - api/core/effect\n - api/core/rxjs-interop\n - api/core/rxjs-interop/toObservable\n - api/core/rxjs-interop/toSignal\n - api/core/signal\n - guide/rxjs-interop#error-and-completion\n - guide/rxjs-interop#initial-values\n - guide/rxjs-interop#initialvalue-选项\n - guide/rxjs-interop#injection-context\n - guide/rxjs-interop#manualcleanup\n - guide/rxjs-interop#requiresync-选项\n - guide/rxjs-interop#rxjs-interop\n - guide/rxjs-interop#rxjs-互操作\n - guide/rxjs-interop#the-initialvalue-option\n - guide/rxjs-interop#the-requiresync-option\n - guide/rxjs-interop#timing-of-toobservable\n - guide/rxjs-interop#toobservable\n - guide/rxjs-interop#toobservable-的时序\n - guide/rxjs-interop#tosignal\n - guide/rxjs-interop#undefined-initial-values\n - guide/rxjs-interop#undefined-初始值\n - guide/rxjs-interop#出错与结束\n - guide/rxjs-interop#初始值\n - guide/rxjs-interop#注入上下文\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/rxjs-interop.md?message=docs%3A%20请简述你的修改...\n-->"}