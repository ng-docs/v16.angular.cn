{"id":"guide/http-interceptor-use-cases","title":"HTTP -  interceptor use-cases","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-interceptor-use-cases.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http----interceptor-use-cases\" translation-result=\"on\">HTTP 拦截器用例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP -  interceptor use-cases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">以下是拦截器的一些常见用法。</p><p translation-origin=\"off\">Following are a number of common uses for interceptors.</p>\n\n<h2 id=\"set-default-headers\" translation-result=\"on\">设置默认标题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Set default headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">应用通常会使用拦截器来设置外发请求的默认请求头。</p><p translation-origin=\"off\">Apps often use an interceptor to set default headers on outgoing requests.</p>\n\n<p translation-result=\"on\">该范例应用具有一个 <code>AuthService</code>，它会生成一个认证令牌。在这里，<code>AuthInterceptor</code> 会注入该服务以获取令牌，并对每一个外发的请求添加一个带有该令牌的认证头：</p><p translation-origin=\"off\">The sample app has an <code>AuthService</code> that produces an authorization token.\nHere is its <code>AuthInterceptor</code> that injects that service to get the token and adds an authorization header with that token to every outgoing request:</p>\n\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">这种在克隆请求的同时设置新请求头的操作太常见了，因此它还有一个快捷方式 <code>setHeaders</code>：</p><p translation-origin=\"off\">The practice of cloning a request to set new headers is so common that there's a <code>setHeaders</code> shortcut for it:</p>\n\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p translation-result=\"on\">这种可以修改头的拦截器可以用于很多不同的操作，比如：</p><p translation-origin=\"off\">An interceptor that alters headers can be used for a number of different operations, including:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">认证 / 授权</p><p translation-origin=\"off\">Authentication/authorization</p>\n\n</li>\n<li>\n<p translation-result=\"on\">控制缓存行为。比如 <code>If-Modified-Since</code></p><p translation-origin=\"off\">Caching behavior; for example, <code>If-Modified-Since</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">XSRF 防护</p><p translation-origin=\"off\">XSRF protection</p>\n\n</li>\n</ul>\n<h2 id=\"log-request-and-response-pairs\" translation-result=\"on\">记录请求和响应对<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Log request and response pairs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">因为拦截器可以<em>同时</em>处理请求和响应，所以它们也可以对整个 HTTP 操作执行计时和记录日志等任务。</p><p translation-origin=\"off\">Because interceptors can process the request and response <em>together</em>, they can perform tasks such as timing and logging an entire HTTP operation.</p>\n\n<p translation-result=\"on\">考虑下面这个 <code>LoggingInterceptor</code>，它捕获请求的发起时间、响应的接收时间，并使用注入的 <code>MessageService</code> 来发送总共花费的时间。</p><p translation-origin=\"off\">Consider the following <code>LoggingInterceptor</code>, which captures the time of the request,\nthe time of the response, and logs the outcome with the elapsed time\nwith the injected <code>MessageService</code>.</p>\n\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs/operators';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) =&gt; (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (error) =&gt; (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">RxJS 的 <code>tap</code> 操作符会捕获请求成功了还是失败了。RxJS 的 <code>finalize</code> 操作符无论在返回成功还是失败时都会调用，然后把结果汇报给 <code>MessageService</code>。</p><p translation-origin=\"off\">The RxJS <code>tap</code> operator captures whether the request succeeded or failed.\nThe RxJS <code>finalize</code> operator is called when the response observable either returns an error or completes and reports the outcome to the <code>MessageService</code>.</p>\n\n<p translation-result=\"on\">在这个可观察对象的流中，无论是 <code>tap</code> 还是 <code>finalize</code> 接触过的值，都会照常发送给调用者。</p><p translation-origin=\"off\">Neither <code>tap</code> nor <code>finalize</code> touch the values of the observable stream returned to the caller.</p>\n\n<p><a id=\"custom-json-parser\"></a></p>\n<h2 id=\"custom-json-parsing\" translation-result=\"on\">自定义 JSON 解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Custom JSON parsing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">拦截器可用来以自定义实现替换内置的 JSON 解析。</p><p translation-origin=\"off\">Interceptors can be used to replace the built-in JSON parsing with a custom implementation.</p>\n\n<p translation-result=\"on\">以下示例中的 <code>CustomJsonInterceptor</code> 演示了如何实现此目的。如果截获的请求期望一个 <code>'json'</code> 响应，则将 <code>responseType</code> 更改为 <code>'text'</code> 以禁用内置的 JSON 解析。然后，通过注入的 <code>JsonParser</code> 解析响应。</p><p translation-origin=\"off\">The <code>CustomJsonInterceptor</code> in the following example demonstrates how to achieve this.\nIf the intercepted request expects a <code>'json'</code> response, the <code>responseType</code> is changed to <code>'text'</code> to disable the built-in JSON parsing.\nThen the response is parsed via the injected <code>JsonParser</code>.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event =&gt; this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &amp;&amp; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然后，你可以实现自己的自定义 <code>JsonParser</code>。这是一个具有特殊日期接收器的自定义 JsonParser。</p><p translation-origin=\"off\">You can then implement your own custom <code>JsonParser</code>.\nHere is a custom JsonParser that has a special date reviver.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\">你提供 <code>CustomParser</code> 以及 <code>CustomJsonInterceptor</code>。</p><p translation-origin=\"off\">You provide the <code>CustomParser</code> along with the <code>CustomJsonInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h2 id=\"cache-requests\" translation-result=\"on\">缓存请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Cache requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">拦截器还可以自行处理这些请求，而不用转发给 <code>next.handle()</code>。</p><p translation-origin=\"off\">Interceptors can handle requests by themselves, without forwarding to <code>next.handle()</code>.</p>\n\n<p translation-result=\"on\">比如，你可能会想缓存某些请求和响应，以便提升性能。你可以把这种缓存操作委托给某个拦截器，而不破坏你现有的各个数据服务。</p><p translation-origin=\"off\">For example, you might decide to cache certain requests and responses to improve performance.\nYou can delegate caching to an interceptor without disturbing your existing data services.</p>\n\n<p translation-result=\"on\">下例中的 <code>CachingInterceptor</code> 演示了这种方法。</p><p translation-origin=\"off\">The <code>CachingInterceptor</code> in the following example demonstrates this approach.</p>\n\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>isCacheable()</code> 函数用于决定该请求是否允许缓存。在这个例子中，只有发到包搜索 API 的 GET 请求才是可以缓存的。</p><p translation-origin=\"off\">The <code>isCacheable()</code> function determines if the request is cacheable.\nIn this sample, only GET requests to the package search API are cacheable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果该请求是不可缓存的，该拦截器会把该请求转发给链表中的下一个处理器</p><p translation-origin=\"off\">If the request is not cacheable, the interceptor forwards the request to the next handler in the chain</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可缓存的请求在缓存中找到了，该拦截器就会通过 <code>of()</code> 函数返回一个已缓存的响应体的<em>可观察对象</em>，然后绕过 <code>next</code> 处理器（以及所有其它下游拦截器）</p><p translation-origin=\"off\">If a cacheable request is found in the cache, the interceptor returns an <code>of()</code> <em>observable</em> with the cached response, by-passing the <code>next</code> handler and all other interceptors downstream</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可缓存的请求不在缓存中，代码会调用 <code>sendRequest()</code>。这个函数会把请求转发给 <code>next.handle()</code>，它会最终调用服务器并返回来自服务器的响应对象。</p><p translation-origin=\"off\">If a cacheable request is not in cache, the code calls <code>sendRequest()</code>.\nThis function forwards the request to <code>next.handle()</code> which ultimately calls the server and returns the server's response.</p>\n\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n  return next.handle(req).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">请注意 <code>sendRequest()</code> 是如何在响应返回应用程序时拦截它的。此方法通过 <code>tap()</code> 操作符将响应联入管道，其回调会将响应添加到缓存中。</p><p translation-origin=\"off\">Notice how <code>sendRequest()</code> intercepts the response on its way back to the application.\nThis method pipes the response through the <code>tap()</code> operator, whose callback adds the response to the cache.</p>\n\n<p translation-result=\"on\">原始响应会不经过修改地沿着拦截器链回到应用程序的调用者处。</p><p translation-origin=\"off\">The original response continues untouched back up through the chain of interceptors to the application caller.</p>\n\n<p translation-result=\"on\">数据服务（例如 <code>PackageSearchService</code>）并不知道它们的某些 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求实际上返回的是已缓存的响应。</p><p translation-origin=\"off\">Data services, such as <code>PackageSearchService</code>, are unaware that some of their <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests actually return cached responses.</p>\n\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h2 id=\"use-interceptors-to-request-multiple-values\" translation-result=\"on\">使用拦截器请求多个值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Use interceptors to request multiple values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常会返回一个可观察对象，它会发出一个值（数据或错误）。拦截器可以把它改成一个可以发出<a href=\"guide/observables\">多个值</a>的可观察对象。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method normally returns an observable that emits a single value, either the data or an error.\nAn interceptor can change this to an observable that emits <a href=\"guide/observables\">multiple values</a>.</p>\n\n<p translation-result=\"on\">修改后的 <code>CachingInterceptor</code> 版本可以返回一个立即发出所缓存响应的可观察对象，然后把请求发送到包搜索 API，然后把修改过的搜索结果重新发出一次。</p><p translation-origin=\"off\">The following revised version of the <code>CachingInterceptor</code> optionally returns an observable that immediately emits the cached response, sends the request on to the package search API, and emits again later with the updated search results.</p>\n\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><em>cache-then-refresh</em> 选项是通过自定义标头 <code>x-refresh</code> 来触发的。</p><p translation-origin=\"off\">The <em>cache-then-refresh</em> option is triggered by the presence of a custom <code>x-refresh</code> header.</p>\n\n<p translation-result=\"on\"><code>PackageSearchComponent</code> 上的复选框切换了 <code>withRefresh</code> 标志，这是 <code>PackageSearchService.search()</code> 的参数之一。<code>search()</code> 方法创建了自定义标头 <code>x-refresh</code>，并在调用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 之前将其添加到请求中。</p><p translation-origin=\"off\">A checkbox on the <code>PackageSearchComponent</code> toggles a <code>withRefresh</code> flag, which is one of the arguments to <code>PackageSearchService.search()</code>.\nThat <code>search()</code> method creates the custom <code>x-refresh</code> header and adds it to the request before calling <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">修改后的 <code>CachingInterceptor</code> 会发起一个服务器请求，而不管有没有缓存的值。\n就像 <a href=\"guide/http-interceptor-use-cases#send-request\">前面</a> 的 <code>sendRequest()</code> 方法一样进行订阅。\n在订阅 <code>results$</code> 可观察对象时，就会发起这个请求。</p><p translation-origin=\"off\">The revised <code>CachingInterceptor</code> sets up a server request whether there's a cached value or not, using the same <code>sendRequest()</code> method described <a href=\"guide/http-interceptor-use-cases#send-request\">above</a>.\nThe <code>results$</code> observable makes the request when subscribed.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果没有缓存值，拦截器直接返回 <code>results$</code>。</p><p translation-origin=\"off\">If there's no cached value, the interceptor returns <code>results$</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果有缓存的值，这些代码就会把缓存的响应加入到 <code>result$</code> 的<em>管道</em>中。这会生成一个重组后的 Observable，它会发出两次响应，故此订阅者将会看到一个包含这两个响应的序列。</p><p translation-origin=\"off\">If there is a cached value, the code <em>pipes</em> the cached response onto <code>results$</code>. This produces a recomposed observable that emits two responses, so subscribers will see a sequence of these two responses:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">立即发出的已缓存的响应</p><p translation-origin=\"off\">The cached response that's emitted immediately</p>\n\n</li>\n<li>\n<p translation-result=\"on\">稍后发出来自服务器的响应</p><p translation-origin=\"off\">The response from the server, that's emitted later</p>\n\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n\n  <div class=\"reviewed\">最后复查时间：11/8/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-intercept-requests-and-responses\n - guide/http-optimize-server-interaction\n-->\n<!-- links from this doc:\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/http-interceptor-use-cases#cache-requests\n - guide/http-interceptor-use-cases#custom-json-parsing\n - guide/http-interceptor-use-cases#http----interceptor-use-cases\n - guide/http-interceptor-use-cases#http-拦截器用例\n - guide/http-interceptor-use-cases#log-request-and-response-pairs\n - guide/http-interceptor-use-cases#send-request\n - guide/http-interceptor-use-cases#set-default-headers\n - guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\n - guide/http-interceptor-use-cases#使用拦截器请求多个值\n - guide/http-interceptor-use-cases#缓存请求\n - guide/http-interceptor-use-cases#自定义-json-解析\n - guide/http-interceptor-use-cases#记录请求和响应对\n - guide/http-interceptor-use-cases#设置默认标题\n - guide/observables\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-interceptor-use-cases.md?message=docs%3A%20请简述你的修改...\n-->"}