{"id":"guide/http-pass-metadata-to-interceptors","title":"HTTP - Pass metadata to interceptors","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-pass-metadata-to-interceptors.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http---pass-metadata-to-interceptors\" translation-result=\"on\">HTTP - 将元数据传递给拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP - Pass metadata to interceptors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">许多拦截器都需要进行配置或从配置中受益。考虑一个重试失败请求的拦截器。默认情况下，拦截器可能会重试请求三次，但是对于特别容易出错或敏感的请求，你可能要改写这个重试次数。</p><p translation-origin=\"off\">Many interceptors require or benefit from configuration.\nConsider an interceptor that retries failed requests.\nBy default, the interceptor might retry a request three times, but you might want to override this retry count for particularly error-prone or sensitive requests.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求包含一个<em>上下文</em>，该上下文可以携带有关请求的元数据。该上下文可供拦截器读取或修改，尽管发送请求时它并不会传输到后端服务器。这允许应用程序或其他拦截器使用配置参数来标记这些请求，比如重试请求的次数。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests contain a <em>context</em> that can carry metadata about the request.\nThis context is available for interceptors to read or modify, though it is not transmitted to the backend server when the request is sent.\nThis lets applications or other interceptors tag requests with configuration parameters, such as how many times to retry a request.</p>\n\n<h2 id=\"create-a-context-token\" translation-result=\"on\">创建上下文标记<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Create a context token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 用于在上下文中存储和检索值。你可以用 <code>new</code> 运算符创建上下文令牌，如以下例所示：</p><p translation-origin=\"off\">Angular stores and retrieves a value in the context using an <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code>.\nYou can create a context token using the <code>new</code> operator, as in the following example:</p>\n\n<code-example header=\"creating a context token\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"context-token\">\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 创建期间传递的 lambda 函数 <code>() =&gt; 3</code> 有两个用途：</p><p translation-origin=\"off\">The lambda function <code>() =&gt; 3</code> passed during the creation of the <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> serves two purposes:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它允许 TypeScript 推断此令牌的类型：<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>。这个请求上下文是类型安全的 —— 从请求上下文中读取令牌将返回适当类型的值。</p><p translation-origin=\"off\">It lets TypeScript infer the type of this token:\n<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>\nThe request context is type-safe —reading a token from a request's context returns a value of the appropriate type.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它会设置令牌的默认值。如果尚未为此令牌设置其他值，那么这就是请求上下文返回的值。使用默认值可以避免检查是否已设置了特定值。</p><p translation-origin=\"off\">It sets the default value for the token.\nThis is the value that the request context returns if no other value was set for this token.\nUsing a default value avoids the need to check if a particular value is set.</p>\n\n</li>\n</ol>\n<h2 id=\"set-context-values-when-making-a-request\" translation-result=\"on\">发出请求时设置上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Set context values when making a request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">发出请求时，你可以提供一个 <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> 实例，在该实例中你已经设置了一些上下文值。</p><p translation-origin=\"off\">When making a request, you can provide an <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> instance, in which you have already set the context values.</p>\n\n<code-example header=\"setting context values\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"set-context\">\nthis.httpClient\n    .get('/data/feed', {\n      context: new <a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a>().set(RETRY_COUNT, 5),\n    })\n    .subscribe(results =&gt; {/* ... */});\n\n</code-example>\n<h2 id=\"read-context-values-in-an-interceptor\" translation-result=\"on\">在拦截器中读取上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Read context values in an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code> 在给定请求的上下文中读取令牌的值。如果尚未显式设置令牌的值，则 Angular 将返回标记中指定的默认值。</p><p translation-origin=\"off\">Within an interceptor, you can read the value of a token in a given request's context with <code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code>.\nIf you have not explicitly set a value for the token, Angular returns the default value specified in the token.</p>\n\n<code-example header=\"reading context values in an interceptor\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"reading-context\">\nimport {retry} from 'rxjs';\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<h2 id=\"contexts-are-mutable\" translation-result=\"on\">上下文是可变的（Mutable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Contexts are mutable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">与 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 实例的大多数其他方面不同，请求上下文是可变的，并且在请求的其他不可变转换过程中仍然存在。这允许拦截器通过此上下文协调来操作。比如，<code>RetryInterceptor</code> 示例可以使用第二个上下文令牌来跟踪在执行给定请求期间发生过多少错误：</p><p translation-origin=\"off\">Unlike most other aspects of <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> instances, the request context is mutable and persists across other immutable transformations of the request.\nThis lets interceptors coordinate operations through the context.\nFor instance, the <code>RetryInterceptor</code> example could use a second context token to track how many errors occur during the execution of a given request:</p>\n\n<code-example header=\"coordinating operations through the context\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\">\nimport {retry, tap} from 'rxjs/operators';\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\nexport const ERROR_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 0);\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        tap({\n              // An error has occurred, so increment this request's ERROR_COUNT.\n             error: () =&gt; req.context.set(ERROR_COUNT, req.context.get(ERROR_COUNT) + 1)\n            }),\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：11/15/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpContext\n - api/common/http/HttpContext#get\n - api/common/http/HttpContextToken\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - guide/http-pass-metadata-to-interceptors#contexts-are-mutable\n - guide/http-pass-metadata-to-interceptors#create-a-context-token\n - guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\n - guide/http-pass-metadata-to-interceptors#http---将元数据传递给拦截器\n - guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\n - guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\n - guide/http-pass-metadata-to-interceptors#上下文是可变的mutable\n - guide/http-pass-metadata-to-interceptors#创建上下文标记\n - guide/http-pass-metadata-to-interceptors#发出请求时设置上下文值\n - guide/http-pass-metadata-to-interceptors#在拦截器中读取上下文值\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-pass-metadata-to-interceptors.md?message=docs%3A%20请简述你的修改...\n-->"}