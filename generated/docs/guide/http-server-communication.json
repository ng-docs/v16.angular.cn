{"id":"guide/http-server-communication","title":"HTTP Server communication","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-server-communication.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-server-communication\" translation-result=\"on\">HTTP 服务器通信<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP Server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">大多数前端应用程序都要通过 HTTP 协议与服务器通信，以下载或上传数据以及访问其他后端服务。</p><p translation-origin=\"off\">Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services.</p>\n\n<h2 id=\"setup-for-server-communication\" translation-result=\"on\">服务器通讯的准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup for server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要想使用 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，就要先导入 Angular 的 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。大多数应用都会在根模块 <code>AppModule</code> 中导入它。</p><p translation-origin=\"off\">Before you can use <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, you need to import the Angular <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>.\nMost apps do so in the root <code>AppModule</code>.</p>\n\n<code-example header=\"app/app.module.ts (excerpt)\" path=\"http/src/app/app.module.ts\" region=\"sketch\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    // import <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> after BrowserModule.\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  declarations: [\n    AppComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n</code-example>\n<p translation-result=\"on\">然后，你可以把 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务注入成一个应用类的依赖项，如下面的 <code>ConfigService</code> 例子所示。</p><p translation-origin=\"off\">You can then inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service as a dependency of an application class, as shown in the following <code>ConfigService</code> example.</p>\n\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务为所有工作都使用了<a href=\"guide/glossary#observable\" title=\"可观察的定义\">可观察对象</a>。你必须导入范例代码片段中出现的 RxJS 可观察对象和操作符。比如 <code>ConfigService</code> 中的这些导入就很典型。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service makes use of <a href=\"guide/glossary#observable\" title=\"Observable definition\">observables</a> for all transactions.\nYou must import the RxJS observable and operator symbols that appear in the example snippets.\nThese <code>ConfigService</code> imports are typical.</p>\n\n<code-example header=\"app/config/config.service.ts (RxJS imports)\" path=\"http/src/app/config/config.service.ts\" region=\"rxjs-imports\">\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, retry } from 'rxjs/operators';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以运行本指南随附的<live-example></live-example>。</p><p translation-origin=\"off\">You can run the <live-example></live-example> that accompanies this guide.</p>\n\n<p translation-result=\"on\">示例应用不需要数据服务器。它依赖于 <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular 的 <em>in-memory-web-api</em></a>，该模块替换了 <em>HttpClient</em> 模块的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。这个替代服务模拟了 REST 后端的行为。</p><p translation-origin=\"off\">The sample app does not require a data server.\nIt relies on the <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular <em>in-memory-web-api</em></a>, which replaces the <em>HttpClient</em> module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.\nThe replacement service simulates the behavior of a REST-like backend.</p>\n\n<p translation-result=\"on\">查看 <code>AppModule</code> 中的 <em>imports</em>，就能了解它是如何配置的。</p><p translation-origin=\"off\">Look at the <code>AppModule</code> <em>imports</em> to see how it is configured.</p>\n\n</div>\n<h2 id=\"requesting-data-from-a-server\" translation-result=\"on\">从服务器请求数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Requesting data from a server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> 方法从服务器获取数据。该异步方法会发送一个 HTTP 请求，并返回一个 Observable，它会在收到响应时发出所请求到的数据。返回的类型取决于你调用时传入的 <code>observe</code> 和 <code>responseType</code> 参数。</p><p translation-origin=\"off\">Use the <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> method to fetch data from a server.\nThe asynchronous method sends an HTTP request, and returns an Observable that emits the requested data when the response is received.\nThe return type varies based on the <code>observe</code> and <code>responseType</code> values that you pass to the call.</p>\n\n<p translation-result=\"on\"><code>get()</code> 方法有两个参数。要获取的端点 URL，以及一个可以用来配置请求的<em>选项</em>对象。</p><p translation-origin=\"off\">The <code>get()</code> method takes two arguments; the endpoint URL from which to fetch, and an <em>options</em> object that is used to configure the request.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p translation-result=\"on\">这些重要的选项包括 <em>observe</em> 和 <em>responseType</em> 属性。</p><p translation-origin=\"off\">Important options include the <em>observe</em> and <em>responseType</em> properties.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>observe</em> 选项用于指定要返回的响应内容。</p><p translation-origin=\"off\">The <em>observe</em> option specifies how much of the response to return</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>responseType</em> 选项指定返回数据的格式。</p><p translation-origin=\"off\">The <em>responseType</em> option specifies the format in which to return data</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">使用 <code>options</code> 对象来配置外发请求的其他方面。例如，在添加标头信息时，此服务会使用 <code>headers</code> 选项的属性来设置默认头信息。</p><p translation-origin=\"off\">Use the <code>options</code> object to configure various other aspects of an outgoing request.\nIn adding headers, for example, the service set the default headers using the <code>headers</code> option property.</p>\n\n<p translation-result=\"on\">使用 <code>params</code> 属性来配置带有 HTTP URL 参数的请求，使用 <code>reportProgress</code> 选项来监听传输大量数据时的进度事件。</p><p translation-origin=\"off\">Use the <code>params</code> property to configure a request with HTTP URL parameters, and the <code>reportProgress</code> option to listen for progress events when transferring large amounts of data.</p>\n\n</div>\n<p translation-result=\"on\">应用经常会从服务器请求 JSON 数据。在 <code>ConfigService</code> 例子中，该应用需要服务器 <code>config.json</code> 上的一个配置文件来指定资源的 URL。</p><p translation-origin=\"off\">Applications often request JSON data from a server.\nIn the <code>ConfigService</code> example, the app needs a configuration file on the server, <code>config.json</code>, that specifies resource URLs.</p>\n\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p translation-result=\"on\">要获取这类数据，<code>get()</code> 调用需要以下几个选项：<code>{observe: 'body', responseType: 'json'}</code>。这些是这些选项的默认值，所以下面的例子不会传递 options 对象。后面几节展示了一些额外的选项。</p><p translation-origin=\"off\">To fetch this kind of data, the <code>get()</code> call needs the following options: <code>{observe: 'body', responseType: 'json'}</code>.\nThese are the default values for those options, so the following examples do not pass the options object.\nLater sections show some of the additional option possibilities.</p>\n\n<p><a id=\"config-service\"></a></p>\n<p translation-result=\"on\">这个例子符合通过定义一个可复用的可<a href=\"guide/glossary#service\" title=\"服务定义\">注入服务</a>来执行数据处理功能来创建可伸缩解决方案的最佳实践。除了提取数据外，该服务还可以对数据进行后处理，添加错误处理，并添加重试逻辑。</p><p translation-origin=\"off\">The example conforms to the best practices for creating scalable solutions by defining a re-usable <a href=\"guide/glossary#service\" title=\"service definition\">injectable service</a> to perform the data-handling functionality.\nIn addition to fetching data, the service can post-process the data, add error handling, and add retry logic.</p>\n\n<p translation-result=\"on\"><code>ConfigService</code> 使用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法获取这个文件。</p><p translation-origin=\"off\">The <code>ConfigService</code> fetches this file using the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p translation-result=\"on\"><code>ConfigComponent</code> 注入了 <code>ConfigService</code> 并调用了 <code>getConfig</code> 服务方法。</p><p translation-origin=\"off\">The <code>ConfigComponent</code> injects the <code>ConfigService</code> and calls the <code>getConfig</code> service method.</p>\n\n<p translation-result=\"on\">由于该服务方法返回了一个 <code>Observable</code> 配置数据，该组件会<em>订阅</em>该方法的返回值。订阅回调只会对后处理进行最少量的处理。它会把数据字段复制到组件的 <code>config</code> 对象中，该对象在组件模板中是数据绑定的，用于显示。</p><p translation-origin=\"off\">Because the service method returns an <code>Observable</code> of configuration data, the component <em>subscribes</em> to the method's return value.\nThe subscription callback performs minimal post-processing.\nIt copies the data fields into the component's <code>config</code> object, which is data-bound in the component template for display.</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe((data: Config) =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\" translation-result=\"on\">启动请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Starting the request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">对于所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法返回的 Observable 上调用 <code>subscribe()</code> 之前，该方法都不会开始其 HTTP 请求。</p><p translation-origin=\"off\">For all <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods, the method doesn't begin its HTTP request until you call <code>subscribe()</code> on the observable the method returns.</p>\n\n<p translation-result=\"on\">这适用于 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p><p translation-origin=\"off\">This is true for <em>all</em> <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>methods</em>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">当组件被销毁时，你应该总是取消订阅 Observable。</p><p translation-origin=\"off\">You should always unsubscribe from an observable when a component is destroyed.</p>\n\n</div>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法返回的可观察对象都设计为<em>冷的</em>。HTTP 请求的执行都是<em>延期执行的</em>，让你可以用 <code>tap</code> 和 <code>catchError</code> 这样的操作符来在实际执行 HTTP 请求之前，先对这个可观察对象进行扩展。</p><p translation-origin=\"off\">All observables returned from <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods are <em>cold</em> by design.\nExecution of the HTTP request is <em>deferred</em>, letting you extend the observable with additional operations such as  <code>tap</code> and <code>catchError</code> before anything actually happens.</p>\n\n<p translation-result=\"on\">调用 <code>subscribe()</code> 会触发此 Observable 的执行，并导致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 请求并将其发送到服务器。</p><p translation-origin=\"off\">Calling <code>subscribe()</code> triggers execution of the observable and causes <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> to compose and send the HTTP request to the server.</p>\n\n<p translation-result=\"on\">可以把这些 Observable 看做实际 HTTP 请求的<em>蓝图</em>。</p><p translation-origin=\"off\">Think of these observables as <em>blueprints</em> for actual HTTP requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">事实上，每个 <code>subscribe()</code> 都会启动 observable 的一次单独的、独立的执行。订阅两次就会导致两次 HTTP 请求。</p><p translation-origin=\"off\">In fact, each <code>subscribe()</code> initiates a separate, independent execution of the observable.\nSubscribing twice results in two HTTP requests.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\" translation-result=\"on\">请求输入一个类型的响应<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Requesting a typed response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可以构造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求来声明响应对象的类型，以便让输出更容易、更明确。所指定的响应类型会在编译时充当类型断言。</p><p translation-origin=\"off\">Structure your <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> request to declare the type of the response object, to make consuming the output easier and more obvious.\nSpecifying the response type acts as a type assertion at compile time.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">指定响应类型是为了告诉 TypeScript 应该将响应视为给定类型的声明。这是一个编译期检查，不能保证服务器的响应一定是这种类型的对象。服务器有责任确保返回服务器 API 所指定的类型。</p><p translation-origin=\"off\">Specifying the response type is a declaration to TypeScript that it should treat your response as being of the given type.\nThis is a build-time check and doesn't guarantee that the server actually responds with an object of this type.\nIt is up to the server to ensure that the type specified by the server API is returned.</p>\n\n</div>\n<p translation-result=\"on\">要指定响应对象类型，首先要定义一个具有必需属性的接口。这里要使用接口而不是类，因为响应对象是普通对象，无法自动转换成类的实例。</p><p translation-origin=\"off\">To specify the response object type, first define an interface with the required properties.\nUse an interface rather than a class, because the response is a plain object that cannot be automatically converted to an instance of a class.</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p translation-result=\"on\">接下来，在服务器中把该接口指定为 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 调用的类型参数。</p><p translation-origin=\"off\">Next, specify that interface as the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> call's type parameter in the service.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">当你将一个接口作为类型参数传给 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法时，要使用 <a href=\"guide/rx-library#operators\">RxJS 的 <code>map</code> 操作符</a>来根据 UI 的需要变换响应数据。然后就可以将转换后的数据传给 <a href=\"api/common/AsyncPipe\">async 管道</a>了。</p><p translation-origin=\"off\">When you pass an interface as a type parameter to the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method, use the <a href=\"guide/rx-library#operators\">RxJS <code>map</code> operator</a> to transform the response data as needed by the UI.\nYou can then pass the transformed data to the <a href=\"api/common/AsyncPipe\">async pipe</a>.</p>\n\n</div>\n<p translation-result=\"on\">修改后的组件方法，其回调函数中获取一个带类型的对象，它易于使用，且消费起来更安全：</p><p translation-origin=\"off\">The callback in the updated component method receives a typed data object, which is easier and safer to consume:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe((data: Config) =&gt; this.config = { ...data });\n}\n\n</code-example>\n<p translation-result=\"on\">要访问接口中定义的属性，必须将从 JSON 获得的普通对象显式转换为所需的响应类型。比如，以下 <code>subscribe</code> 回调会将 <code>data</code> 作为对象接收，然后进行类型转换以访问属性。</p><p translation-origin=\"off\">To access properties that are defined in an interface, you must explicitly convert the plain object you get from the JSON to the required response type.\nFor example, the following <code>subscribe</code> callback receives <code>data</code> as an Object, and then type-casts it in order to access the properties.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data =&gt; this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\"><code>observe</code> 和 <code>response</code> 类型</header><header ng-should-translate=\"\" translation-origin=\"off\"><code>observe</code> and <code>response</code> types</header>\n\n<p translation-result=\"on\"><code>observe</code> 和 <code>response</code> 选项的类型是<em>字符串联合</em>类型，而不是普通字符串。</p><p translation-origin=\"off\">The types of the <code>observe</code> and <code>response</code> options are <em>string unions</em>, rather than plain strings.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p translation-result=\"on\">这可能导致混淆。例如：</p><p translation-origin=\"off\">This can cause confusion.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p>In the second case, TypeScript infers the type of <code>options</code> to be <code>{responseType: string}</code>.\nThe type is too wide to pass to <code>HttpClient.get</code> which is expecting the type of <code>responseType</code> to be one of the <em>specific</em> strings.\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> is typed explicitly this way so that the compiler can report the correct return type based on the options you provided.</p>\n<p>Use <code>as const</code> to let TypeScript know that you really do mean to use a constant string type:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\" translation-result=\"on\">读取完整的响应体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading the full response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在前面的例子中，对 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的调用没有指定任何选项。默认情况下，它返回了响应体中包含的 JSON 数据。</p><p translation-origin=\"off\">In the previous example, the call to <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> did not specify any options.\nBy default, it returned the JSON data contained in the response body.</p>\n\n<p translation-result=\"on\">你可能还需要关于这次对话的更多信息。比如，有时候服务器会返回一个特殊的响应头或状态码，来指出某些在应用的工作流程中很重要的条件。</p><p translation-origin=\"off\">You might need more information about the transaction than is contained in the response body.\nSometimes servers return special headers or status codes to indicate certain conditions that are important to the application workflow.</p>\n\n<p translation-result=\"on\">可以用 <code>get()</code> 方法的 <code>observe</code> 选项来告诉 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的响应对象：</p><p translation-origin=\"off\">Tell <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> that you want the full response with the <code>observe</code> option of the <code>get()</code> method:</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p translation-result=\"on\">现在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 会返回一个 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类型的 <code>Observable</code>，而不只是 JSON 数据。</p><p translation-origin=\"off\">Now <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> returns an <code>Observable</code> of type <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> rather than just the JSON data contained in the body.</p>\n\n<p translation-result=\"on\">该组件的 <code>showConfigResponse()</code> 方法会像显示配置数据一样显示响应头：</p><p translation-origin=\"off\">The component's <code>showConfigResponse()</code> method displays the response headers as well as the configuration:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p translation-result=\"on\">如你所见，该响应对象具有一个带有正确类型的 <code>body</code> 属性。</p><p translation-origin=\"off\">As you can see, the response object has a <code>body</code> property of the correct type.</p>\n\n\n  <div class=\"reviewed\">最后复查时间：2/27/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/http\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - api/core/Injectable\n - api/core/NgModule\n - api/platform-browser/BrowserModule\n - guide/glossary#observable\n - guide/glossary#service\n - guide/http-server-communication#http-server-communication\n - guide/http-server-communication#http-服务器通信\n - guide/http-server-communication#reading-the-full-response\n - guide/http-server-communication#requesting-a-typed-response\n - guide/http-server-communication#requesting-data-from-a-server\n - guide/http-server-communication#setup-for-server-communication\n - guide/http-server-communication#starting-the-request\n - guide/http-server-communication#从服务器请求数据\n - guide/http-server-communication#启动请求\n - guide/http-server-communication#服务器通讯的准备工作\n - guide/http-server-communication#请求输入一个类型的响应\n - guide/http-server-communication#读取完整的响应体\n - guide/rx-library#operators\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-server-communication.md?message=docs%3A%20请简述你的修改...\n-->"}