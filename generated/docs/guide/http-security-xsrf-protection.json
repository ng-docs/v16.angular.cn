{"id":"guide/http-security-xsrf-protection","title":"HTTP client - Security: Cross-Site Request Forgery (XSRF) protection","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-security-xsrf-protection.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-client---security-cross-site-request-forgery-xsrf-protection\" translation-result=\"on\">HTTP 客户端 - 安全性：跨站点请求伪造（XSRF）保护<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP client - Security: Cross-Site Request Forgery (XSRF) protection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">跨站请求伪造（XSRF 或 CSRF）</a>是一种攻击技术，攻击者可以通过这种技术诱使已完成身份验证的用户在你的网站上不知不觉地执行某些操作。</p><p translation-origin=\"off\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">Cross-Site Request Forgery (XSRF or CSRF)</a> is an attack technique by which the attacker can trick an authenticated user into unknowingly executing actions on your website.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 支持用于防止 XSRF 攻击的<a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">通用机制</a>。当执行 HTTP 请求时，拦截器从 cookie 中读取令牌，默认为 <code>XSRF-TOKEN</code>，并将其设置为 HTTP 标头 <code>X-XSRF-TOKEN</code>。因为只有在你的域上运行的代码才能读取 cookie，这样后端就可以确定 HTTP 请求来自你的客户端程序而不是攻击者。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports a <a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">common mechanism</a> used to prevent XSRF attacks.\nWhen performing HTTP requests, an interceptor reads a token from a cookie, by default <code>XSRF-TOKEN</code>, and sets it as an HTTP header, <code>X-XSRF-TOKEN</code>.\nBecause only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.</p>\n\n<p translation-result=\"on\">默认情况下，拦截器会在所有的修改型请求中（比如 POST 等）把这个请求头发送给使用相对 URL 的请求。但不会在 GET/HEAD 请求中发送，也不会发送给使用绝对 URL 的请求。</p><p translation-origin=\"off\">By default, an interceptor sends this header on all mutating requests (such as POST)\nto relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.</p>\n\n<p translation-result=\"on\">要获得这种优点，你的服务器需要在页面加载或首个 GET 请求中把一个名叫 <code>XSRF-TOKEN</code> 的标记写入可被 JavaScript 读到的会话 cookie 中。而在后续的请求中，服务器可以验证这个 cookie 是否与 HTTP 头 <code>X-XSRF-TOKEN</code> 的值一致，以确保只有运行在你自己域名下的代码才能发起这个请求。这个标记必须对每个用户都是唯一的，并且必须能被服务器验证，因此不能由客户端自己生成标记。把这个标记设置为你的站点认证信息并且加了盐（salt）的摘要，以提升安全性。</p><p translation-origin=\"off\">To take advantage of this, your server needs to set a token in a JavaScript readable session cookie called <code>XSRF-TOKEN</code> on either the page load or the first GET request.\nOn subsequent requests the server can verify that the cookie matches the <code>X-XSRF-TOKEN</code> HTTP header, and therefore be sure that only code running on your domain could have sent the request.\nThe token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens.\nSet the token to a digest of your site's authentication cookie with a salt for added security.</p>\n\n<p translation-result=\"on\">为了防止多个 Angular 应用共享同一个域名或子域时出现冲突，要给每个应用分配一个唯一的 cookie 名称。</p><p translation-origin=\"off\">To prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 仅支持受 XSRF 保护的客户端部分</em>。后端服务必须配置为能够为页面设置 cookie，并验证在所有符合条件的请求中是否存在该标头。如果后端服务未能正确设置它们，则会让 Angular 的默认保护失效。</p><p translation-origin=\"off\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports only the client half of the XSRF protection scheme.</em>\nYour backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests.\nFailing to do so renders Angular's default protection ineffective.</p>\n\n</div>\n<h2 id=\"configure-custom-cookieheader-names\" translation-result=\"on\">配置自定义 cookie/标头名称<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#configure-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Configure custom cookie/header names<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#configure-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你的后端服务中对 XSRF 标记的 cookie 或头使用了不一样的名字，就要使用 <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> 来覆盖掉默认值。</p><p translation-origin=\"off\">If your backend service uses different names for the XSRF token cookie or header, use <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> to override the defaults.</p>\n\n<code-example path=\"http/src/app/app.module.ts\" region=\"xsrf\">\nimports: [\n  <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  HttpClientXsrfModule.withOptions({\n    cookieName: 'My-Xsrf-Cookie',\n    headerName: 'My-Xsrf-Header',\n  }),\n],\n\n</code-example>\n<p><a id=\"testing-requests\"></a></p>\n\n  <div class=\"reviewed\">最后复查时间：11/14/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpClientXsrfModule#withOptions\n - guide/http-security-xsrf-protection#configure-custom-cookieheader-names\n - guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\n - guide/http-security-xsrf-protection#http-客户端---安全性跨站点请求伪造xsrf保护\n - guide/http-security-xsrf-protection#配置自定义-cookie标头名称\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-security-xsrf-protection.md?message=docs%3A%20请简述你的修改...\n-->"}